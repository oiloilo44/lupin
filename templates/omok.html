{% extends "base.html" %}
{% from "components/chat.html" import chat_panel, chat_resources, chat_init_script %}

{% block content %}
<div id="nicknameForm" class="nickname-form">
    <h3>ì˜¤ëª© ê²Œì„ ì°¸ì—¬</h3>
    <p>ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ê³  ê²Œì„ì— ì°¸ì—¬í•˜ì„¸ìš”</p>
    <input type="text" id="nicknameInput" placeholder="ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”" maxlength="10">
    <button onclick="joinGame()">ê²Œì„ ì°¸ì—¬</button>
</div>

<!-- ê¸°ì¡´ ê²Œì„ ì´ì–´í•˜ê¸° UI -->
<div id="existingGameForm" class="nickname-form" style="display: none;">
    <h3>ê¸°ì¡´ ê²Œì„ ë°œê²¬</h3>
    <p>ì§„í–‰ ì¤‘ì¸ ê²Œì„ì´ ìˆìŠµë‹ˆë‹¤. ì–´ë–»ê²Œ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?</p>
    <div style="display: flex; gap: 10px; justify-content: center;">
        <button onclick="continueExistingGame()" class="primary">ì´ì–´í•˜ê¸°</button>
        <button onclick="startNewGame()" class="secondary">ìƒˆ ê²Œì„</button>
    </div>
</div>

<div id="gameArea" style="display: none;">
    <div class="connection-status" id="connectionStatus" style="display: none;">
        <span id="connectionIcon">ğŸ”´</span>
        <span id="connectionText">ì—°ê²° ëŠê¹€</span>
    </div>
    <div class="game-status" id="gameStatus">í”Œë ˆì´ì–´ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...</div>
    
    <div id="gameLayout" style="display: flex; gap: 20px;">
        <div style="flex: 1;">
            <canvas id="omokBoard" width="450" height="450" style="border: 2px solid #333; background: #ffffff; cursor: pointer; touch-action: none;"></canvas>
        </div>
        
        <div style="width: 180px;">
            <div class="game-info-panel">
                <h4>í”Œë ˆì´ì–´</h4>
                <div id="playerList"></div>
            </div>
            
            <div class="game-info-panel">
                <h4>í˜„ì¬ í„´</h4>
                <div id="currentTurn">-</div>
            </div>
            
            <div class="game-info-panel">
                <h4>ê²Œì„ ì •ë³´</h4>
                <div class="game-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="moveCount">0</div>
                        <div class="stat-label">ì´ ìˆ˜</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="gameTime">00:00</div>
                        <div class="stat-label">ê²½ê¸° ì‹œê°„</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- í•˜ë‹¨ ì±„íŒ… ì˜ì—­ -->
    <div style="margin-top: 20px; max-width: 600px;">
        {{ chat_panel(title="ê²Œì„ ì±„íŒ…", height="120px") }}
    </div>
    
    <div style="margin-top: 15px; text-align: center;">
        <button onclick="requestUndo()" id="undoButton" style="padding: 8px 16px; margin: 5px;" disabled>ë¬´ë¥´ê¸°</button>
        <button onclick="requestRestart()" style="padding: 8px 16px; margin: 5px;">ê²Œì„ ì¬ì‹œì‘</button>
        <button onclick="confirmLeaveRoom()" style="padding: 8px 16px; margin: 5px;">ë°© ë‚˜ê°€ê¸°</button>
    </div>
</div>

<!-- ëª¨ë‹¬ ì˜¤ë²„ë ˆì´ -->
<div class="modal-overlay" id="modalOverlay">
    <div class="modal" id="modal">
        <div class="modal-header">
            <h3 class="modal-title" id="modalTitle">ì œëª©</h3>
        </div>
        <div class="modal-body" id="modalBody">
            ë‚´ìš©
        </div>
        <div class="modal-footer" id="modalFooter">
            <!-- ë²„íŠ¼ë“¤ì´ ë™ì ìœ¼ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤ -->
        </div>
    </div>
</div>

<!-- í† ìŠ¤íŠ¸ ì»¨í…Œì´ë„ˆ -->
<div class="toast-container" id="toastContainer"></div>

<!-- ìƒ‰ì¢…ì´ ì»¨í…Œì´ë„ˆ -->
<div class="confetti-container" id="confettiContainer"></div>
{% endblock %}

{% block extra_css %}
{{ chat_resources() }}
{% endblock %}

{% block extra_js %}
{{ chat_init_script() }}
<script>
const canvas = document.getElementById('omokBoard');
const ctx = canvas.getContext('2d');
const roomId = '{{ room_id }}';
const sessionId = '{{ session_id }}';
let ws = null;
let reconnectAttempts = 0;
const maxReconnectAttempts = 5;
let reconnectTimeout = null;
let connectionStatus = 'disconnected'; // 'connected', 'disconnected', 'reconnecting'
let gameState = {
    board: Array(15).fill(null).map(() => Array(15).fill(0)),
    currentPlayer: 1
};
let myPlayerNumber = null;
let players = [];
let gameEnded = false;
let waitingForRestart = false;
let lastMove = null;
let hoverPosition = null;
let winningLine = null;
let stoneAnimations = new Map();
let gameStats = { moves: 0, startTime: null };
let waitingForUndo = false;
let winnerNumber = null;
let myNickname = null;

// ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸
function updateConnectionStatus(status, text) {
    connectionStatus = status;
    const statusElement = document.getElementById('connectionStatus');
    const iconElement = document.getElementById('connectionIcon');
    const textElement = document.getElementById('connectionText');
    
    if (status === 'connected') {
        statusElement.style.display = 'none';
    } else {
        statusElement.style.display = 'block';
        statusElement.className = `connection-status ${status}`;
        
        if (status === 'disconnected') {
            iconElement.textContent = 'ğŸ”´';
            textElement.textContent = text || 'ì—°ê²° ëŠê¹€';
        } else if (status === 'reconnecting') {
            iconElement.textContent = 'ğŸŸ¡';
            textElement.textContent = text || 'ì¬ì—°ê²° ì‹œë„ ì¤‘...';
        }
    }
}

// WebSocket ì—°ê²° í•¨ìˆ˜
function connectWebSocket(isReconnect = false) {
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${window.location.host}/ws/${roomId}`;
    
    try {
        ws = new WebSocket(wsUrl);
        
        ws.onopen = function() {
            console.log('WebSocket connected');
            updateConnectionStatus('connected');
            reconnectAttempts = 0;
            
            // ì±„íŒ… ì—°ê²° ì„¤ì •
            if (myNickname) {
                setupChatConnection(ws, myNickname);
            }
            
            if (isReconnect) {
                // ì¬ì—°ê²° ì‹œ ì„¸ì…˜ ë³µì›
                ws.send(JSON.stringify({
                    type: 'reconnect',
                    session_id: sessionId
                }));
            }
        };
        
        ws.onmessage = handleWebSocketMessage;
        ws.onclose = handleWebSocketClose;
        ws.onerror = handleWebSocketError;
        
    } catch (error) {
        console.error('WebSocket connection failed:', error);
        handleConnectionFailure();
    }
}

// ì¬ì—°ê²° ë¡œì§ (exponential backoff)
function attemptReconnect() {
    if (reconnectAttempts >= maxReconnectAttempts) {
        updateConnectionStatus('disconnected', 'ì¬ì—°ê²° ì‹¤íŒ¨');
        showModal('ì—°ê²° ì‹¤íŒ¨', 'ì„œë²„ì™€ì˜ ì—°ê²°ì„ ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.<br>í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ê±°ë‚˜ ë‚˜ì¤‘ì— ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', [
            { text: 'ìƒˆë¡œê³ ì¹¨', class: 'primary', onclick: () => location.reload() },
            { text: 'ë©”ì¸ìœ¼ë¡œ', class: 'secondary', onclick: () => window.location.href = '/' }
        ]);
        return;
    }
    
    reconnectAttempts++;
    const delay = Math.min(1000 * Math.pow(2, reconnectAttempts - 1), 10000);
    
    updateConnectionStatus('reconnecting', `ì¬ì—°ê²° ì‹œë„ ì¤‘... (${reconnectAttempts}/${maxReconnectAttempts})`);
    
    reconnectTimeout = setTimeout(() => {
        console.log(`Reconnection attempt ${reconnectAttempts}/${maxReconnectAttempts}`);
        connectWebSocket(true);
    }, delay);
}

// WebSocket ë‹«í˜ ì²˜ë¦¬
function handleWebSocketClose(event) {
    console.log('WebSocket closed:', event);
    
    if (event.code === 1000) {
        // ì •ìƒ ì¢…ë£Œ
        updateConnectionStatus('disconnected', 'ì—°ê²° ì¢…ë£Œ');
        return;
    }
    
    // ë¹„ì •ìƒ ì¢…ë£Œ - ì¬ì—°ê²° ì‹œë„
    updateConnectionStatus('disconnected', 'ì—°ê²° ëŠê¹€');
    
    if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
    }
    
    // ì¦‰ì‹œ ì²« ë²ˆì§¸ ì¬ì—°ê²° ì‹œë„
    setTimeout(() => attemptReconnect(), 1000);
}

// WebSocket ì—ëŸ¬ ì²˜ë¦¬
function handleWebSocketError(error) {
    console.error('WebSocket error:', error);
}

// ì—°ê²° ì‹¤íŒ¨ ì²˜ë¦¬
function handleConnectionFailure() {
    updateConnectionStatus('disconnected', 'ì—°ê²° ì‹¤íŒ¨');
    setTimeout(() => attemptReconnect(), 2000);
}

// ì˜¤ëª©íŒ ê·¸ë¦¬ê¸°
function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // ë™ì  í¬ê¸° ê³„ì‚°
    const boardSize = Math.min(canvas.width, canvas.height);
    const cellSize = (boardSize - 60) / 14; // ì—¬ë°± 30pxì”© ë¹¼ê³  14ì¹¸ìœ¼ë¡œ ë‚˜ëˆ”
    const margin = (boardSize - cellSize * 14) / 2;
    
    // ë°°ê²½
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // ê²©ì ê·¸ë¦¬ê¸°
    ctx.strokeStyle = '#000';
    ctx.lineWidth = Math.max(1, cellSize / 30); // í¬ê¸°ì— ë¹„ë¡€í•œ ì„  êµµê¸°
    
    for (let i = 0; i < 15; i++) {
        // ì„¸ë¡œì„ 
        ctx.beginPath();
        ctx.moveTo(margin + i * cellSize, margin);
        ctx.lineTo(margin + i * cellSize, boardSize - margin);
        ctx.stroke();
        
        // ê°€ë¡œì„ 
        ctx.beginPath();
        ctx.moveTo(margin, margin + i * cellSize);
        ctx.lineTo(boardSize - margin, margin + i * cellSize);
        ctx.stroke();
    }
    
    // ì¤‘ì‹¬ì  ê·¸ë¦¬ê¸°
    const centerPoints = [[7, 7], [3, 3], [3, 11], [11, 3], [11, 11]];
    ctx.fillStyle = '#000';
    centerPoints.forEach(([x, y]) => {
        ctx.beginPath();
        ctx.arc(margin + x * cellSize, margin + y * cellSize, Math.max(2, cellSize / 10), 0, 2 * Math.PI);
        ctx.fill();
    });
    
    // ë§ˆìš°ìŠ¤ ì˜¤ë²„ ë¯¸ë¦¬ë³´ê¸° (ì‹¤ì œ ëŒ ê·¸ë¦¬ê¸° ì „ì—)
    const myPlayer = players.find(p => p.player_number === myPlayerNumber);
    if (hoverPosition && !gameEnded && players.length === 2 && myPlayer && gameState.currentPlayer === myPlayer.color) {
        const [hx, hy] = hoverPosition;
        if (gameState.board[hy][hx] === 0) {
            const stoneRadius = Math.max(8, cellSize * 0.4);
            ctx.beginPath();
            ctx.arc(margin + hx * cellSize, margin + hy * cellSize, stoneRadius, 0, 2 * Math.PI);
            ctx.fillStyle = gameState.currentPlayer === 1 ? 'rgba(0, 0, 0, 0.3)' : 'rgba(255, 255, 255, 0.5)';
            ctx.fill();
            ctx.strokeStyle = gameState.currentPlayer === 1 ? 'rgba(0, 0, 0, 0.5)' : 'rgba(51, 51, 51, 0.5)';
            ctx.lineWidth = Math.max(1, cellSize / 30);
            ctx.stroke();
        }
    }
    
    // ëŒ ê·¸ë¦¬ê¸°
    const stoneRadius = Math.max(8, cellSize * 0.4);
    for (let y = 0; y < 15; y++) {
        for (let x = 0; x < 15; x++) {
            if (gameState.board[y][x] !== 0) {
                // ëŒ ê·¸ë¦¬ê¸° ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼
                ctx.save();
                
                const centerX = margin + x * cellSize;
                const centerY = margin + y * cellSize;
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, stoneRadius, 0, 2 * Math.PI);
                ctx.fillStyle = gameState.board[y][x] === 1 ? '#000' : '#fff';
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = Math.max(1, cellSize / 30);
                ctx.stroke();
                
                // ìµœê·¼ ë‘” ìˆ˜ ê°•ì¡°
                if (lastMove && lastMove.x === x && lastMove.y === y) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, stoneRadius * 1.25, 0, 2 * Math.PI);
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = Math.max(2, cellSize / 15);
                    ctx.stroke();
                }
                
                // ìŠ¹ë¦¬ ë¼ì¸ ê°•ì¡°
                if (winningLine && winningLine.some(pos => pos.x === x && pos.y === y)) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, stoneRadius * 1.5, 0, 2 * Math.PI);
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = Math.max(3, cellSize / 10);
                    ctx.stroke();
                    
                    // ë°˜ì§ì´ëŠ” íš¨ê³¼
                    const time = Date.now();
                    const pulse = Math.sin(time / 200) * 0.3 + 0.7;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, stoneRadius * pulse, 0, 2 * Math.PI);
                    ctx.fillStyle = gameState.board[y][x] === 1 ? 
                        `rgba(255, 215, 0, ${0.3 * pulse})` : 
                        `rgba(255, 215, 0, ${0.2 * pulse})`;
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
    }
}

// ìŠ¹ë¦¬ ì¡°ê±´ í™•ì¸ (ìŠ¹ë¦¬ ë¼ì¸ ë°˜í™˜ ì¶”ê°€)
function checkWin(board, x, y, player) {
    const directions = [
        [0, 1], [1, 0], [1, 1], [1, -1]
    ];
    
    for (let [dx, dy] of directions) {
        let count = 1;
        let winLine = [{x, y}];
        
        // í•œ ë°©í–¥ìœ¼ë¡œ í™•ì¸
        for (let i = 1; i < 5; i++) {
            const nx = x + dx * i;
            const ny = y + dy * i;
            if (nx >= 0 && nx < 15 && ny >= 0 && ny < 15 && board[ny][nx] === player) {
                count++;
                winLine.push({x: nx, y: ny});
            } else {
                break;
            }
        }
        
        // ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ í™•ì¸
        for (let i = 1; i < 5; i++) {
            const nx = x - dx * i;
            const ny = y - dy * i;
            if (nx >= 0 && nx < 15 && ny >= 0 && ny < 15 && board[ny][nx] === player) {
                count++;
                winLine.unshift({x: nx, y: ny});
            } else {
                break;
            }
        }
        
        if (count == 5) {
            return winLine; // ì •í™•íˆ 5ê°œë§Œ ë°˜í™˜
        }
    }
    
    return null;
}

// ëª¨ë‹¬ ì‹œìŠ¤í…œ
function showModal(title, body, buttons = []) {
    document.getElementById('modalTitle').textContent = title;
    document.getElementById('modalBody').innerHTML = body;
    
    const footer = document.getElementById('modalFooter');
    footer.innerHTML = '';
    
    buttons.forEach(button => {
        const btn = document.createElement('button');
        btn.className = `modal-button ${button.class || 'secondary'}`;
        btn.textContent = button.text;
        btn.onclick = button.onclick;
        footer.appendChild(btn);
    });
    
    document.getElementById('modalOverlay').classList.add('show');
}

function hideModal() {
    document.getElementById('modalOverlay').classList.remove('show');
}

function showWinModal(winner, isMyWin) {
    const modal = document.getElementById('modal');
    modal.className = 'modal win-modal';
    
    const icon = isMyWin ? 'ğŸ‰' : 'ğŸ˜”';
    const iconClass = isMyWin ? 'victory' : 'defeat';
    const messageClass = isMyWin ? 'victory' : 'defeat';
    const message = isMyWin ? 'ìŠ¹ë¦¬!' : 'íŒ¨ë°°';
    const submessage = isMyWin ? 'ì¶•í•˜í•©ë‹ˆë‹¤!' : 'ë‹¤ìŒì— ë” ì˜í•´ë³´ì„¸ìš”!';
    
    const body = `
        <div class="win-icon ${iconClass}">${icon}</div>
        <div class="win-message ${messageClass}">${message}</div>
        <div class="win-submessage">${submessage}</div>
    `;
    
    showModal('ê²Œì„ ì¢…ë£Œ', body, [
        {
            text: 'í™•ì¸',
            class: 'primary',
            onclick: () => {
                hideModal();
                modal.className = 'modal';
            }
        }
    ]);
}

function showConfirmModal(title, message, onConfirm, onCancel) {
    showModal(title, message, [
        {
            text: 'ì·¨ì†Œ',
            class: 'secondary',
            onclick: () => {
                hideModal();
                if (onCancel) onCancel();
            }
        },
        {
            text: 'í™•ì¸',
            class: 'primary',
            onclick: () => {
                hideModal();
                if (onConfirm) onConfirm();
            }
        }
    ]);
}

function showRestartRequestModal(requesterName) {
    showModal('ê²Œì„ ì¬ì‹œì‘ ìš”ì²­', 
        `${requesterName}ë‹˜ì´ ê²Œì„ ì¬ì‹œì‘ì„ ìš”ì²­í–ˆìŠµë‹ˆë‹¤.<br>ì¬ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`, [
        {
            text: 'ê±°ë¶€',
            class: 'secondary',
            onclick: () => {
                hideModal();
                ws.send(JSON.stringify({
                    type: 'restart_response',
                    accepted: false,
                    session_id: sessionId
                }));
            }
        },
        {
            text: 'ë™ì˜',
            class: 'success',
            onclick: () => {
                hideModal();
                ws.send(JSON.stringify({
                    type: 'restart_response',
                    accepted: true,
                    session_id: sessionId
                }));
            }
        }
    ]);
}

// ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ì¶”ê°€
function handleHover(e) {
    const myPlayer = players.find(p => p.player_number === myPlayerNumber);
    if (!ws || players.length < 2 || !myPlayer || gameState.currentPlayer !== myPlayer.color || gameEnded) {
        hoverPosition = null;
        drawBoard();
        return;
    }
    
    const pos = getEventPosition(e);
    const x = pos.x;
    const y = pos.y;
    
    if (x >= 0 && x < 15 && y >= 0 && y < 15) {
        hoverPosition = [x, y];
        drawBoard();
    }
}

canvas.addEventListener('mousemove', handleHover);
canvas.addEventListener('touchmove', function(e) {
    e.preventDefault();
    handleHover(e);
});

function clearHover() {
    hoverPosition = null;
    drawBoard();
}

canvas.addEventListener('mouseleave', clearHover);
canvas.addEventListener('touchcancel', clearHover);

// í´ë¦­ ë° í„°ì¹˜ ì´ë²¤íŠ¸
function getEventPosition(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
    
    // ìº”ë²„ìŠ¤ì˜ ì‹¤ì œ í¬ê¸°ì™€ í™”ë©´ í¬ê¸°ì˜ ë¹„ìœ¨ ê³„ì‚°
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    // ìŠ¤ì¼€ì¼ë§ì„ ê³ ë ¤í•œ ì¢Œí‘œ ê³„ì‚°
    const canvasX = (clientX - rect.left) * scaleX;
    const canvasY = (clientY - rect.top) * scaleY;
    
    // ë™ì  í¬ê¸° ê³„ì‚° (drawBoard í•¨ìˆ˜ì™€ ë™ì¼)
    const boardSize = Math.min(canvas.width, canvas.height);
    const cellSize = (boardSize - 60) / 14;
    const margin = (boardSize - cellSize * 14) / 2;
    
    return {
        x: Math.round((canvasX - margin) / cellSize),
        y: Math.round((canvasY - margin) / cellSize)
    };
}

function handleGameMove(e) {
    e.preventDefault();
    const myPlayer = players.find(p => p.player_number === myPlayerNumber);
    if (!ws || players.length < 2 || !myPlayer || gameState.currentPlayer !== myPlayer.color || gameEnded) {
        return;
    }
    
    const pos = getEventPosition(e);
    const x = pos.x;
    const y = pos.y;
    
    if (x >= 0 && x < 15 && y >= 0 && y < 15 && gameState.board[y][x] === 0) {
        // ëŒ ë†“ê¸° - í”Œë ˆì´ì–´ì˜ ìƒ‰ìƒìœ¼ë¡œ
        gameState.board[y][x] = myPlayer.color;
        lastMove = {x, y};
        
        // ì´ ìˆ˜ íšŸìˆ˜ë¥¼ ë³´ë“œì˜ ëŒ ê°œìˆ˜ë¡œ ê³„ì‚°
        gameStats.moves = 0;
        for (let dy = 0; dy < 15; dy++) {
            for (let dx = 0; dx < 15; dx++) {
                if (gameState.board[dy][dx] !== 0) {
                    gameStats.moves++;
                }
            }
        }
        
        // ìŠ¹ë¦¬ í™•ì¸
        const winLine = checkWin(gameState.board, x, y, myPlayer.color);
        if (winLine) {
            gameEnded = true;
            winningLine = winLine;
            createConfetti(); // ìŠ¹ë¦¬ ì¶•í•˜ íš¨ê³¼
            ws.send(JSON.stringify({
                type: 'game_end',
                winner: myPlayer.player_number,  // ìŠ¹ìëŠ” player_numberë¡œ ì „ì†¡
                game_state: gameState,
                last_move: lastMove,
                winning_line: winLine,
                session_id: sessionId
            }));
            return;
        }
        
        // í„´ ë³€ê²½
        gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
        
        // ì„œë²„ì— ì „ì†¡
        ws.send(JSON.stringify({
            type: 'move',
            game_state: gameState,
            last_move: lastMove,
            session_id: sessionId
        }));
        
        drawBoard();
        updateUI();
        updateUndoButton();
    }
}

canvas.addEventListener('click', handleGameMove);
canvas.addEventListener('touchend', handleGameMove);

// WebSocket ë©”ì‹œì§€ ì²˜ë¦¬
function handleWebSocketMessage(event) {
    const data = JSON.parse(event.data);
    console.log('Received WebSocket message:', data);
    
    // ì±„íŒ… ë©”ì‹œì§€ ì²˜ë¦¬
    handleChatWebSocketMessage(data);
    
    if (data.type === 'room_update') {
        players = data.room.players;
        if (myPlayerNumber === null && players.length > 0) {
            const currentNickname = myNickname || document.getElementById('nicknameInput').value.trim();
            const myPlayer = players.find(p => p.nickname === currentNickname);
            if (myPlayer) {
                myPlayerNumber = myPlayer.player_number;
                
                // ì„¸ì…˜ ì •ë³´ ì—…ë°ì´íŠ¸ (í”Œë ˆì´ì–´ ë²ˆí˜¸ ì¶”ê°€)
                saveGameSession({
                    nickname: currentNickname,
                    sessionId: sessionId,
                    playerNumber: myPlayerNumber,
                    color: myPlayer.color,
                    joinedAt: Date.now()
                });
            }
        }
        updateUI();
        
        if (players.length === 1) {
            showToast('ì…ì¥ ì™„ë£Œ', 'ìƒëŒ€ë°©ì„ ê¸°ë‹¤ë¦¬ê³  ìˆìŠµë‹ˆë‹¤...', 'info', 5000);
            showGameArea();
            drawBoard();
        } else if (players.length === 2) {
            showGameArea();
            gameStats.startTime = Date.now();
            showToast('ê²Œì„ ì‹œì‘', 'ëª¨ë“  í”Œë ˆì´ì–´ê°€ ì°¸ì—¬í–ˆìŠµë‹ˆë‹¤. ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤!', 'success');
            drawBoard();
        }
    } else if (data.type === 'reconnect_success') {
        // ê²Œì„ ìƒíƒœ ë³µì›
        if (data.room && data.room.game_state) {
            gameState = data.room.game_state;
        }
        if (data.room && data.room.players) {
            players = data.room.players;
        }
        if (data.player) {
            myPlayerNumber = data.player.player_number;
        }
        if (data.room && data.room.game_ended !== undefined) {
            gameEnded = data.room.game_ended;
        }
        if (data.room && data.room.winner) {
            winnerNumber = data.room.winner;
        }
        
        // ì±„íŒ… íˆìŠ¤í† ë¦¬ ë³µì›
        if (data.room && data.room.chat_history) {
            // ì±„íŒ… ë©”ì‹œì§€ë“¤ì„ ì±„íŒ… ì‹œìŠ¤í…œì— ë³µì›
            data.room.chat_history.forEach(msg => {
                if (typeof displayChatMessage === 'function') {
                    displayChatMessage(msg.nickname, msg.message, msg.timestamp, msg.player_number === myPlayerNumber);
                }
            });
        }
        
        // ë¬´ë¸Œ íˆìŠ¤í† ë¦¬ì—ì„œ ë§ˆì§€ë§‰ ìˆ˜ ë³µì›
        if (data.move_history && data.move_history.length > 0) {
            const lastMoveEntry = data.move_history[data.move_history.length - 1];
            lastMove = lastMoveEntry.move;
        }
        
        // ì´ ìˆ˜ íšŸìˆ˜ë¥¼ ë³´ë“œì˜ ëŒ ê°œìˆ˜ë¡œ ê³„ì‚°
        gameStats.moves = 0;
        for (let y = 0; y < 15; y++) {
            for (let x = 0; x < 15; x++) {
                if (gameState.board[y][x] !== 0) {
                    gameStats.moves++;
                }
            }
        }
        
        showGameArea();
        drawBoard();
        updateUI();
        updateUndoButton();
        showToast('ì¬ì—°ê²° ì„±ê³µ', 'ê²Œì„ ìƒíƒœê°€ ë³µì›ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
    } else if (data.type === 'player_disconnected') {
        showToast('í”Œë ˆì´ì–´ ì—°ê²° ëŠê¹€', `${data.nickname}ë‹˜ì˜ ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤.`, 'warning', 5000);
    } else if (data.type === 'player_reconnected') {
        showToast('í”Œë ˆì´ì–´ ì¬ì—°ê²°', `${data.nickname}ë‹˜ì´ ë‹¤ì‹œ ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'success', 3000);
    } else if (data.type === 'game_update') {
        gameState = data.game_state;
        if (data.last_move) {
            lastMove = data.last_move;
            // ì´ ìˆ˜ íšŸìˆ˜ë¥¼ ë³´ë“œì˜ ëŒ ê°œìˆ˜ë¡œ ê³„ì‚°
            gameStats.moves = 0;
            for (let y = 0; y < 15; y++) {
                for (let x = 0; x < 15; x++) {
                    if (gameState.board[y][x] !== 0) {
                        gameStats.moves++;
                    }
                }
            }
        }
        drawBoard();
        updateUI();
        updateUndoButton();
    } else if (data.type === 'game_end') {
        gameEnded = true;
        gameState = data.game_state;
        if (data.last_move) {
            lastMove = data.last_move;
        }
        if (data.winning_line) {
            winningLine = data.winning_line;
        }
        
        // ì´ ìˆ˜ íšŸìˆ˜ë¥¼ ë³´ë“œì˜ ëŒ ê°œìˆ˜ë¡œ ê³„ì‚°
        gameStats.moves = 0;
        for (let y = 0; y < 15; y++) {
            for (let x = 0; x < 15; x++) {
                if (gameState.board[y][x] !== 0) {
                    gameStats.moves++;
                }
            }
        }
        
        winnerNumber = data.winner;
        const isMyWin = data.winner === myPlayerNumber;
        if (isMyWin) {
            createConfetti(); // ë‚´ê°€ ì´ê²¼ì„ ë•Œë§Œ ìƒ‰ì¢…ì´ íš¨ê³¼
        }
        
        // ìŠ¹ë¦¬ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
        startWinAnimation();
        
        setTimeout(() => showWinModal(data.winner, isMyWin), 1500);
    } else if (data.type === 'restart_request') {
        const requesterName = players.find(p => p.player_number === data.from)?.nickname || 'ìƒëŒ€ë°©';
        
        if (data.is_requester) {
            // ìš”ì²­ìì—ê²ŒëŠ” ëŒ€ê¸° ë©”ì‹œì§€ í‘œì‹œ
            showModal('ê²Œì„ ì¬ì‹œì‘ ìš”ì²­', 'ìƒëŒ€ë°©ì—ê²Œ ì¬ì‹œì‘ ìš”ì²­ì„ ë³´ëƒˆìŠµë‹ˆë‹¤. ì‘ë‹µì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...', [
                { text: 'í™•ì¸', class: 'primary', onclick: hideModal }
            ]);
        } else {
            // ìƒëŒ€ë°©ì—ê²ŒëŠ” ë™ì˜ ì—¬ë¶€ í™•ì¸
            showRestartRequestModal(requesterName);
        }
    } else if (data.type === 'restart_accepted') {
        gameEnded = false;
        waitingForRestart = false;
        lastMove = null;
        winningLine = null;
        winnerNumber = null;
        gameStats = { moves: 0, startTime: Date.now() };
        gameState = data.game_state;
        
        // í”Œë ˆì´ì–´ ìƒ‰ìƒ ì •ë³´ ì—…ë°ì´íŠ¸
        if (data.players) {
            players = data.players;
        }
        
        hideModal(); // ìš”ì²­ìì˜ ëŒ€ê¸° ëª¨ë‹¬ ìë™ ë‹«ê¸°
        drawBoard();
        updateUI();
        
        const gameNum = data.games_played || 1;
        showToast('ê²Œì„ ì¬ì‹œì‘', `${gameNum}ë²ˆì§¸ ê²Œì„ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!`, 'success');
    } else if (data.type === 'restart_rejected') {
        waitingForRestart = false;
        showModal('ì•Œë¦¼', 'ìƒëŒ€ë°©ì´ ì¬ì‹œì‘ì„ ê±°ë¶€í–ˆìŠµë‹ˆë‹¤.', [
            { text: 'í™•ì¸', class: 'primary', onclick: hideModal }
        ]);
    } else if (data.type === 'undo_request') {
        const requesterName = players.find(p => p.player_number === data.from)?.nickname || 'ìƒëŒ€ë°©';
        
        if (data.is_requester) {
            // ìš”ì²­ìì—ê²ŒëŠ” ëŒ€ê¸° ë©”ì‹œì§€ í‘œì‹œ
            showModal('ë¬´ë¥´ê¸° ìš”ì²­', 'ìƒëŒ€ë°©ì—ê²Œ ë¬´ë¥´ê¸° ìš”ì²­ì„ ë³´ëƒˆìŠµë‹ˆë‹¤. ì‘ë‹µì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...', [
                { text: 'í™•ì¸', class: 'primary', onclick: hideModal }
            ]);
        } else {
            // ìƒëŒ€ë°©ì—ê²ŒëŠ” ë™ì˜ ì—¬ë¶€ í™•ì¸
            showUndoRequestModal(requesterName);
        }
    } else if (data.type === 'undo_accepted') {
        gameState = data.game_state;
        // ì´ ìˆ˜ íšŸìˆ˜ë¥¼ ë³´ë“œì˜ ëŒ ê°œìˆ˜ë¡œ ë‹¤ì‹œ ê³„ì‚°
        gameStats.moves = 0;
        for (let y = 0; y < 15; y++) {
            for (let x = 0; x < 15; x++) {
                if (gameState.board[y][x] !== 0) {
                    gameStats.moves++;
                }
            }
        }
        waitingForUndo = false;
        lastMove = null; // ë¬´ë¥´ê¸° í›„ ë§ˆì§€ë§‰ ìˆ˜ í•˜ì´ë¼ì´íŠ¸ ì œê±°
        hideModal(); // ìš”ì²­ìì˜ ëŒ€ê¸° ëª¨ë‹¬ ìë™ ë‹«ê¸°
        drawBoard();
        updateUI();
        updateUndoButton();
        showToast('ë¬´ë¥´ê¸° ì„±ê³µ', 'ë§ˆì§€ë§‰ ìˆ˜ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
    } else if (data.type === 'undo_rejected') {
        waitingForUndo = false;
        showModal('ì•Œë¦¼', 'ìƒëŒ€ë°©ì´ ë¬´ë¥´ê¸°ë¥¼ ê±°ë¶€í–ˆìŠµë‹ˆë‹¤.', [
            { text: 'í™•ì¸', class: 'primary', onclick: hideModal }
        ]);
    } else if (data.type === 'error') {
        showModal('ì˜¤ë¥˜', data.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', [
            { text: 'í™•ì¸', class: 'primary', onclick: () => {
                hideModal();
                window.location.href = '/';
            }}
        ]);
    }
}

// ê²Œì„ ì˜ì—­ í‘œì‹œ
function showGameArea() {
    document.getElementById('nicknameForm').style.display = 'none';
    document.getElementById('existingGameForm').style.display = 'none';
    document.getElementById('gameArea').style.display = 'block';
}

function joinGame() {
    const nickname = document.getElementById('nicknameInput').value.trim();
    if (!nickname) {
        showModal('ì•Œë¦¼', 'ë‹‰ë„¤ì„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.', [
            { text: 'í™•ì¸', class: 'primary', onclick: hideModal }
        ]);
        return;
    }
    
    // ë‹‰ë„¤ì„ ì €ì¥
    myNickname = nickname;
    
    // WebSocket ì—°ê²°
    connectWebSocket();
    
    // ì—°ê²°ë˜ë©´ JOIN ë©”ì‹œì§€ ì „ì†¡
    const waitForConnection = () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
            console.log('WebSocket connected, sending join message');
            // ì±„íŒ… ì—°ê²° ì„¤ì •
            setupChatConnection(ws, nickname);
            ws.send(JSON.stringify({
                type: 'join',
                nickname: nickname,
                session_id: sessionId
            }));
            
            // ì„¸ì…˜ ì •ë³´ ì €ì¥
            saveGameSession({
                nickname: nickname,
                sessionId: sessionId,
                joinedAt: Date.now()
            });
        } else {
            setTimeout(waitForConnection, 100);
        }
    };
    
    waitForConnection();
}

// ê¸°ì¡´ ê²Œì„ ì´ì–´í•˜ê¸°
function continueExistingGame() {
    if (window.pendingSessionData) {
        // ê¸°ì¡´ ì„¸ì…˜ ë°ì´í„° ë³µì›
        myNickname = window.pendingSessionData.nickname;
        myPlayerNumber = window.pendingSessionData.playerNumber;
        
        // WebSocket ì—°ê²°í•˜ê³  ì¬ì—°ê²° ì‹œë„
        connectWebSocket();
        
        const waitForConnection = () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                console.log('Attempting reconnection with session:', window.pendingSessionData.sessionId);
                // ì¬ì—°ê²° ë©”ì‹œì§€ ì „ì†¡
                ws.send(JSON.stringify({
                    type: 'reconnect',
                    session_id: window.pendingSessionData.sessionId
                }));
            } else {
                setTimeout(waitForConnection, 100);
            }
        };
        
        waitForConnection();
    }
}

// ìƒˆ ê²Œì„ ì‹œì‘
function startNewGame() {
    // ë¡œì»¬ ì„¸ì…˜ ì •ë³´ ì‚­ì œ
    clearGameSession();
    
    // UIë¥¼ ë‹‰ë„¤ì„ ì…ë ¥ í™”ë©´ìœ¼ë¡œ ì „í™˜
    document.getElementById('existingGameForm').style.display = 'none';
    document.getElementById('nicknameForm').style.display = 'block';
    
    // ê¸°ì¡´ ì„¸ì…˜ ë°ì´í„° ì´ˆê¸°í™”
    window.pendingSessionData = null;
}

function updateUI() {
    // í”Œë ˆì´ì–´ ëª©ë¡ ì—…ë°ì´íŠ¸
    const playerList = document.getElementById('playerList');
    playerList.innerHTML = players.map(p => {
        const isCurrentPlayer = p.player_number === gameState.currentPlayer;
        const isMe = p.player_number === myPlayerNumber;
        let itemClass = 'player-item';
        if (isCurrentPlayer) itemClass += ' active';
        if (isMe && isCurrentPlayer) itemClass += ' my-turn';
        
        return `
            <div class="${itemClass}">
                <div class="player-name">${p.nickname}${isMe ? ' (ë‚˜)' : ''}</div>
                <div class="player-stone">
                    <span class="stone-indicator ${p.color === 1 ? 'black' : 'white'}"></span>
                    ${p.color === 1 ? 'í‘ëŒ' : 'ë°±ëŒ'}
                </div>
            </div>
        `;
    }).join('');
    
    // í˜„ì¬ í„´ í‘œì‹œ - ìƒ‰ìƒ ê¸°ì¤€ìœ¼ë¡œ ë³€ê²½
    const currentTurn = document.getElementById('currentTurn');
    const currentPlayer = players.find(p => p.color === gameState.currentPlayer);
    if (currentPlayer) {
        const isMyTurn = currentPlayer.player_number === myPlayerNumber;
        currentTurn.innerHTML = `
            <div class="player-item ${isMyTurn ? 'my-turn' : 'active'}">
                <div class="player-name">${currentPlayer.nickname}${isMyTurn ? ' (ë‚˜)' : ''}</div>
                <div class="player-stone">
                    <span class="stone-indicator ${currentPlayer.color === 1 ? 'black' : 'white'}"></span>
                    ${currentPlayer.color === 1 ? 'í‘ëŒ' : 'ë°±ëŒ'}
                </div>
            </div>
        `;
    } else {
        currentTurn.textContent = '-';
    }
    
    // ê²Œì„ ì •ë³´ ì—…ë°ì´íŠ¸
    document.getElementById('moveCount').textContent = gameStats.moves;
    
    if (gameStats.startTime) {
        const elapsed = Math.floor((Date.now() - gameStats.startTime) / 1000);
        const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const seconds = (elapsed % 60).toString().padStart(2, '0');
        document.getElementById('gameTime').textContent = `${minutes}:${seconds}`;
    }
    
    // ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸
    const gameStatus = document.getElementById('gameStatus');
    if (players.length === 0) {
        gameStatus.textContent = 'ê²Œì„ ì—°ê²° ì¤‘...';
        gameStatus.className = 'game-status waiting';
    } else if (players.length === 1) {
        const waitingPlayer = players[0];
        const isMe = waitingPlayer.player_number === myPlayerNumber;
        if (isMe) {
            gameStatus.textContent = 'ìƒëŒ€ë°©ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘... (ë§í¬ë¥¼ ê³µìœ í•˜ì„¸ìš”)';
        } else {
            gameStatus.textContent = 'ë‹¤ë¥¸ í”Œë ˆì´ì–´ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...';
        }
        gameStatus.className = 'game-status waiting';
    } else if (gameEnded) {
        const winnerName = players.find(p => p.player_number === winnerNumber)?.nickname || 'ìŠ¹ì';
        gameStatus.textContent = `ê²Œì„ ì¢…ë£Œ - ${winnerName} ìŠ¹ë¦¬!`;
        gameStatus.className = 'game-status ended';
    } else {
        gameStatus.textContent = 'ê²Œì„ ì§„í–‰ ì¤‘';
        gameStatus.className = 'game-status playing';
    }
}

function requestRestart() {
    if (!ws || waitingForRestart) {
        return;
    }
    
    if (!gameEnded) {
        showModal('ì•Œë¦¼', 'ê²Œì„ì´ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤. ê²Œì„ì´ ëë‚œ í›„ ì¬ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.', [
            { text: 'í™•ì¸', class: 'primary', onclick: hideModal }
        ]);
        return;
    }
    
    waitingForRestart = true;
    ws.send(JSON.stringify({
        type: 'restart_request',
        from: myPlayerNumber,
        session_id: sessionId
    }));
}

function requestUndo() {
    if (!ws || waitingForUndo || gameEnded || gameStats.moves === 0) {
        return;
    }
    
    const myPlayer = players.find(p => p.player_number === myPlayerNumber);
    if (myPlayer && gameState.currentPlayer === myPlayer.color) {
        showModal('ì•Œë¦¼', 'ìì‹ ì˜ í„´ì—ëŠ” ë¬´ë¥´ê¸°ë¥¼ ìš”ì²­í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', [
            { text: 'í™•ì¸', class: 'primary', onclick: hideModal }
        ]);
        return;
    }
    
    waitingForUndo = true;
    ws.send(JSON.stringify({
        type: 'undo_request',
        from: myPlayerNumber,
        session_id: sessionId
    }));
}

function showUndoRequestModal(requesterName) {
    showModal('ë¬´ë¥´ê¸° ìš”ì²­', 
        `${requesterName}ë‹˜ì´ ë¬´ë¥´ê¸°ë¥¼ ìš”ì²­í–ˆìŠµë‹ˆë‹¤.<br>ë§ˆì§€ë§‰ ìˆ˜ë¥¼ ì·¨ì†Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`, [
        {
            text: 'ê±°ë¶€',
            class: 'secondary',
            onclick: () => {
                hideModal();
                ws.send(JSON.stringify({
                    type: 'undo_response',
                    accepted: false,
                    session_id: sessionId
                }));
            }
        },
        {
            text: 'ë™ì˜',
            class: 'success',
            onclick: () => {
                hideModal();
                ws.send(JSON.stringify({
                    type: 'undo_response',
                    accepted: true,
                    session_id: sessionId
                }));
            }
        }
    ]);
}

function updateUndoButton() {
    const undoButton = document.getElementById('undoButton');
    if (undoButton) {
        const myPlayer = players.find(p => p.player_number === myPlayerNumber);
        const canUndo = ws && !gameEnded && !waitingForUndo && 
                       gameStats.moves > 0 && myPlayer && gameState.currentPlayer !== myPlayer.color;
        undoButton.disabled = !canUndo;
        undoButton.style.opacity = canUndo ? '1' : '0.5';
    }
}

function confirmLeaveRoom() {
    showConfirmModal(
        'ë°© ë‚˜ê°€ê¸°',
        'ì •ë§ë¡œ ê²Œì„ì—ì„œ ë‚˜ê°€ì‹œê² ìŠµë‹ˆê¹Œ?<br>ì§„í–‰ ì¤‘ì¸ ê²Œì„ì´ ì¢…ë£Œë©ë‹ˆë‹¤.',
        () => {
            // ì„¸ì…˜ ì •ë³´ ì‚­ì œ
            clearGameSession();
            
            if (ws) {
                ws.close();
            }
            window.location.href = '/';
        }
    );
}

// í† ìŠ¤íŠ¸ ì•Œë¦¼ ì‹œìŠ¤í…œ
function showToast(title, message, type = 'info', duration = 3000) {
    const toastContainer = document.getElementById('toastContainer');
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    
    toast.innerHTML = `
        <div class="toast-title">${title}</div>
        <div class="toast-message">${message}</div>
    `;
    
    toastContainer.appendChild(toast);
    
    // ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
    setTimeout(() => toast.classList.add('show'), 100);
    
    // ìë™ ì œê±°
    setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
            if (toast.parentNode) {
                toast.parentNode.removeChild(toast);
            }
        }, 300);
    }, duration);
}

// ìƒ‰ì¢…ì´ íš¨ê³¼
function createConfetti() {
    const container = document.getElementById('confettiContainer');
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7'];
    
    for (let i = 0; i < 50; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + '%';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animationDelay = Math.random() * 3 + 's';
        confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';
        container.appendChild(confetti);
        
        // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ì œê±°
        setTimeout(() => {
            if (confetti.parentNode) {
                confetti.parentNode.removeChild(confetti);
            }
        }, 5000);
    }
}

// ìŠ¹ë¦¬ ì• ë‹ˆë©”ì´ì…˜ í•¨ìˆ˜
function startWinAnimation() {
    let animationFrame = 0;
    const animate = () => {
        drawBoard();
        animationFrame++;
        if (animationFrame < 100) {
            requestAnimationFrame(animate);
        }
    };
    animate();
}

// ê²Œì„ ì‹œê°„ ì—…ë°ì´íŠ¸ íƒ€ì´ë¨¸
let gameTimer = null;

function startGameTimer() {
    if (gameTimer) clearInterval(gameTimer);
    gameTimer = setInterval(() => {
        if (gameStats.startTime && !gameEnded) {
            updateUI();
        }
    }, 1000);
}

function stopGameTimer() {
    if (gameTimer) {
        clearInterval(gameTimer);
        gameTimer = null;
    }
}

// ëª¨ë°”ì¼ ë ˆì´ì•„ì›ƒ ì¡°ì •
function adjustMobileLayout() {
    const gameLayout = document.getElementById('gameLayout');
    const canvas = document.getElementById('omokBoard');
    
    if (!canvas) return; // ìº”ë²„ìŠ¤ê°€ ì—†ìœ¼ë©´ ë¦¬í„´
    
    if (window.innerWidth <= 768) {
        gameLayout.style.flexDirection = 'column';
        gameLayout.style.gap = '15px';
        
        // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì • - transform ëŒ€ì‹  ì‹¤ì œ í¬ê¸° ë³€ê²½
        const size = Math.min(window.innerWidth - 60, 320);
        canvas.style.width = size + 'px';
        canvas.style.height = size + 'px';
        canvas.width = size;
        canvas.height = size;
        
        // transform ì œê±° (ë” ì •í™•í•œ ì¢Œí‘œ ê³„ì‚°ì„ ìœ„í•´)
        canvas.style.transform = '';
        canvas.style.transformOrigin = '';
        
        drawBoard();
    } else {
        gameLayout.style.flexDirection = 'row';
        gameLayout.style.gap = '20px';
        
        canvas.style.width = '450px';
        canvas.style.height = '450px';
        canvas.width = 450;
        canvas.height = 450;
        canvas.style.transform = '';
        canvas.style.transformOrigin = '';
        
        drawBoard();
    }
}

window.addEventListener('resize', adjustMobileLayout);
window.addEventListener('orientationchange', function() {
    setTimeout(adjustMobileLayout, 100);
});

// ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ í‚¤
const STORAGE_KEYS = {
    GAME_SESSION: 'omokGameSession',
    ROOM_DATA: 'omokRoomData'
};

// ê²Œì„ ì„¸ì…˜ ì €ì¥
function saveGameSession(sessionData) {
    try {
        localStorage.setItem(STORAGE_KEYS.GAME_SESSION, JSON.stringify({
            ...sessionData,
            timestamp: Date.now(),
            roomId: roomId
        }));
    } catch (error) {
        console.error('Failed to save game session:', error);
    }
}

// ê²Œì„ ì„¸ì…˜ ë¶ˆëŸ¬ì˜¤ê¸°
function loadGameSession() {
    try {
        const data = localStorage.getItem(STORAGE_KEYS.GAME_SESSION);
        if (!data) return null;
        
        const session = JSON.parse(data);
        
        // 24ì‹œê°„ ì´ˆê³¼ëœ ì„¸ì…˜ì€ ì‚­ì œ
        if (Date.now() - session.timestamp > 24 * 60 * 60 * 1000) {
            localStorage.removeItem(STORAGE_KEYS.GAME_SESSION);
            return null;
        }
        
        // ê°™ì€ ë°©ì¸ì§€ í™•ì¸
        if (session.roomId !== roomId) {
            return null;
        }
        
        return session;
    } catch (error) {
        console.error('Failed to load game session:', error);
        return null;
    }
}

// ê²Œì„ ì„¸ì…˜ ì‚­ì œ
function clearGameSession() {
    try {
        localStorage.removeItem(STORAGE_KEYS.GAME_SESSION);
        localStorage.removeItem(STORAGE_KEYS.ROOM_DATA);
    } catch (error) {
        console.error('Failed to clear game session:', error);
    }
}

// ì„¸ì…˜ í™•ì¸ ë° ì´ˆê¸°í™”
function checkExistingSession() {
    const hostNickname = sessionStorage.getItem('hostNickname');
    
    // ì„œë²„ì—ì„œ ì „ë‹¬ëœ ê²Œì„ ìƒíƒœë‚˜ í”Œë ˆì´ì–´ ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸
    const serverGameState = {{ game_state | tojson | safe }};
    const serverPlayerData = {{ player_data | tojson | safe }};
    
    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ê¸°ì¡´ ê²Œì„ ì„¸ì…˜ í™•ì¸
    const localSession = loadGameSession();
    
    if (localSession && localSession.nickname && localSession.sessionId) {
        // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ê¸°ì¡´ ê²Œì„ ì„¸ì…˜ì´ ìˆëŠ” ê²½ìš°
        console.log('Found local game session:', localSession);
        showExistingGamePrompt(localSession);
        return;
    }
    
    if (serverPlayerData && serverPlayerData.nickname) {
        // ì„œë²„ì—ì„œ ì „ë‹¬ëœ ì„¸ì…˜ì´ ìˆëŠ” ê²½ìš°
        console.log('Found server session:', serverPlayerData);
        showExistingGamePrompt({
            nickname: serverPlayerData.nickname,
            sessionId: sessionId,
            playerNumber: serverPlayerData.player_number
        });
        return;
    }
    
    // í˜¸ìŠ¤íŠ¸ ë‹‰ë„¤ì„ì´ ìˆëŠ” ê²½ìš° (ë°© ìƒì„±ì)
    if (hostNickname) {
        const nicknameInput = document.getElementById('nicknameInput');
        if (nicknameInput) {
            nicknameInput.value = hostNickname;
            // ë°© ìƒì„±ìì´ë¯€ë¡œ ë°”ë¡œ ê²Œì„ì— ì°¸ì—¬
            setTimeout(() => {
                showToast('ìë™ ì…ì¥', 'ë°© ìƒì„±ìë¡œ ê²Œì„ì— ì…ì¥í•©ë‹ˆë‹¤...', 'info', 2000);
                setTimeout(joinGame, 1000);
            }, 500);
        }
        // ì‚¬ìš© í›„ ì œê±°
        sessionStorage.removeItem('hostNickname');
    }
}

// ê¸°ì¡´ ê²Œì„ ë°œê²¬ UI í‘œì‹œ
function showExistingGamePrompt(sessionData) {
    document.getElementById('nicknameForm').style.display = 'none';
    document.getElementById('existingGameForm').style.display = 'block';
    
    // ê¸°ì¡´ ê²Œì„ ì •ë³´ í‘œì‹œ
    const existingGameForm = document.getElementById('existingGameForm');
    existingGameForm.querySelector('p').innerHTML = 
        `ì§„í–‰ ì¤‘ì¸ ê²Œì„ì´ ìˆìŠµë‹ˆë‹¤. (${sessionData.nickname})<br>ì–´ë–»ê²Œ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
    
    // ì „ì—­ ë³€ìˆ˜ì— ì„¸ì…˜ ë°ì´í„° ì €ì¥
    window.pendingSessionData = sessionData;
}

// í˜ì´ì§€ ë¡œë“œ ì‹œ ì—°ê²° ìƒíƒœ í™•ì¸ ë° ìë™ ì¬ì—°ê²°
function initializeGame() {
    // ê¸°ì¡´ ì„¸ì…˜ í™•ì¸
    checkExistingSession();
    
    // UI ì´ˆê¸°í™”
    drawBoard();
    startGameTimer();
    adjustMobileLayout();
}

// ì´ˆê¸°í™”
initializeGame();
</script>
{% endblock %}